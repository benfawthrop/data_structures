//
// Created by Benjamin Fawthrop on 4/9/23.
//
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include "genome_hash.h"

// default constructor
genome_hashtable::genome_hashtable(const int &k, const int &N, const float &f) {
    // sets the table size
    if (N == 0) {
        table_size = 100;
    } else table_size = N;
    // sets occupancy
    if (f == 0.0) {
        occ = 0.5;
    } else occ = f;
    k_len = k; // stores kmer length
    actual_size = 0; // sets our counter for table size
    std::vector<hash_node> temp(table_size);
    sequences = temp;
}

// converts the number generated by the hash function
// to an index in the top level vector
int genome_hashtable::getIndex(std::string &str) {
    hash_string_obj h;
    return h(str) % table_size;
}

// inserts an element into the table
void genome_hashtable::insert(hash_node &to_add) {
    // resizes our table if we pass the occupancy threshold
    if (((actual_size + 1) / table_size) > occ) {
        resizeTable(table_size * 2);
    }

    unsigned long int i = getIndex(to_add.genome); // gets index of the node to add
    while (sequences[i].genome != "" && sequences[i].genome != to_add.genome) {
        if (i >= sequences.size()) {
            i = 0;
        } else i++;
    }

    // sets the node at the correct index to the correct node
    sequences[i].genome = to_add.genome;
    for (unsigned long int j = 0; j < to_add.index.size(); j++) {
        sequences[i].index.push_back(to_add.index[j]);
    }
    actual_size++;
}

// resizes and rehashes the table
void genome_hashtable::resizeTable(int new_size) {
    // creates new vector
    table_size = new_size;
    std::vector<hash_node> temp(new_size);
    for (unsigned long int i = 0; i < sequences.size(); i++) {
        // gets new index for the node
        unsigned long int j = getIndex(sequences[i].genome);
        // solves collisions
        while (temp[j].genome != "") {
            if (j >= temp.size()) {
                j = 0;
            } else j++;
        }
        // sets the node to the correct node
        temp[j] = sequences[i];
    }
    sequences = temp; // sets the top level vector to our new one
}

// allows us to easily get a node from our table
hash_node genome_hashtable::operator[](std::string str) {
    unsigned long int i = getIndex(str); // hashes the index to check
    bool alr_hit = false; // checks to make sure we dont loop infinitely
    while (sequences[i].genome != str) {
        // loops until we find the right node
        if (i >= sequences.size()) {
            // loops back to the begining if we hit the end
            i = 0;
            if (!alr_hit) {
                alr_hit = true;
            } else return hash_node();
        } else i++;
    }
    return sequences[i];
}